## 語群
#### SHA-256（Secure Hash Algorithm 256-bit）とは？
任意の長さの原文から固定長の特徴的な値を算出するハッシュ関数（要約関数）の一つ。SHA-2規格に含まれる仕様の一つで、どんな長さの原文からも256ビットのハッシュ値を算出することができる。
SHA-256はいわゆる「暗号学的ハッシュ関数」の一つで、出力値には規則性がなく、計算過程に逆算困難な一方向関数を含むため、ハッシュ値から入力値を割り出したり、同じハッシュ値となる別の入力値を生成するのは容易ではない。
#### ハッシュ関数とは?
任意の長さの入力データを元に数十バイト程度までの短い固定長のデータを算出する関数で、同じ入力値からは必ず同じ値が得られる一方、わずかでも入力値が異なるとまったく違う出力値になる。
#### MyBatisとは？
MyBatisはO/Rマッピング機能を提供する永続性フレームワークです。 
オブジェクト指向言語であるJavaでは、リレーショナルデータベースを扱う場合、テーブル構造とJavaオブジェクトの対応付けが必要となります。 
O/Rマッピングはテーブル構造とJavaオブジェクトを対応付けする機能です。
#### O/Rマッパーとは?
O/Rマッパーとは、オブジェクト指向言語におけるオブジェクト(O)と、リレーショナルデータベース(R)におけるレコードとを対応付けを行う「O/Rマッピング」のためのフレームワークやライブラリの総称である。 
主な、O/Rマッパーとしては、Java言語向けのHibernateやRuby言語向けのActiveRecordなどがある。
# URLとは?
「Uniform Resource Locator」の略称で、インターネット上に存在する情報資源（文書や画像など）の場所を指し示す技術方式です。 通常「プロトコル://ドメイン名/ディレクトリパス名/ファイル名」という形式で構成される**ホームページページの住所**（アドレス）のことです。
![image](https://github.com/koikekatsumi/github-handson/assets/163390515/e13b3df2-83a1-4d71-96de-4e1834414df2)

### プロトコル
インターネット上におけるブラウザとサーバー間の通信種別を表します。以前はhttpが一般的でしたが、よりセキュリティレベルを高めるため、数年前から暗号化されたhttps（Hyper Text Transfer Protocol Secure）が推奨されています。
### ホスト
「www」は、そのサーバーがワールドワイドウェブ対応のウェブサイトを提供していることを示すために、URLの内部にサブドメインとして組み込まれている文字列です。
### ドメイン
ドメインとは、たとえば「```https://example.com```」のURLがあるとすると、そのなかの「```example.com```」の部分のことで、そのサイト専用の住所になります。 URLの核となる部分がドメインである。 ホームページやメールアドレスの運用には、このドメインが必須になります。
### ディレクトリ
サーバー内のフォルダ名と位置を表します。 ホームページは複数のコンテンツを分類して階層的に分けていることが多いです。 ディレクトリ名は、このホームページアドレスがホームページ内のどの階層にあるページなのか示しています。
### ファイル
URLの末尾に記述される「～/file.html」や「～/●●●. html」などの、拡張子のついた文字列のことです。
# クエリ文字列とは?
**サーバーに情報を送るためにURLの末尾につけ足す文字列**（変数）のことです。 通常はキーと値のペアで構成され、ウェブサーバーに要求されるページやリソースに関する追加情報を提供するために使用される。通常、クエリ文字列は「?」でURLのパスと区切られ、その後にキーと値のペアが「&」で区切られます。
例えば、URLが「```https://〇〇〇〇.jp```」 だとします。
このURLにクエリ文字列が加わると、「```https://〇〇〇〇.jp/?×=△△```」のようになります。
「```https://〇〇〇〇.jp/?×=△△```」の「?×=△△」の部分がクエリ文字列です。
![image](https://github.com/koikekatsumi/github-handson/assets/163390515/e2f82937-2b21-4bc0-a21a-d890ca3377f4)

### パス変数（パスパラメーター）とは?
**URLの末尾に付け加えられた変数**（文字列）のことです。 **URLの「?」 以降の文字列がURLパラメーターに当たる。
例　```https://anime.co.jp/sales/{group_id}```　の場合、{group_id}　になります。
** URLパラメーターを利用することで、ユーザーの流入経路を把握したり、Webにおける広告の効果測定などが可能となります。

## クエリ文字列とパス変数の違いとは
### 見た目の違い
①```https://zenn.dev/search```
②```https://zenn.dev/search?q=Laravel```
①と②の見た目違いとして「search」の後に「?〜」が」あるかどうか
①のパスパラメータはsearchの部分になる
②の場合、パスパラメータは①と同じくsearch、クエリパラメータは?q=Laravel

### 中身の違い
次にそれぞれが何を表しているのか確認しましょう！
例:株式会社アニメ（ドメイン：anime.co.jp）に営業部（sales）があり、チームが以下のように分かれているとします。

### salesTable
| id | name |
| ---- | ---- |
| 1 | isono |
| 2 | doraemon |

チームの中のユーザーは以下の通り

### UsersTable
| id | salse_id | name |
| ---- | ---- |---- |
| 1 | 1|  サザエ |
| 2 | 1 | カツオ |
| 3 | 1 | ワカメ |
| 4 | 1 | のび太 |
| 5 | 2 | ドラえもん |
| 6 | 2 | 波平 |

営業部のIsono（磯野）チームのページを表示するとなるとURIは以下のようになります。
```https://anime.co.jp/sales/{group_id}```

パスパラメータ は特定のもの（画面など）を表示したいときに必要になります。
// IsonoチームのsalesTableidは「１」
```https://anime.co.jp/sales/1```

もし、メンバー一覧を画面表示にしたい場合は、下記のURIとします。
```https://anime.co.jp/sales/1/members```

クエリパラメータ は特定のもの（画面など）に条件を加える場合に必要になります。

例：上記のメンバー一覧から特定の人を検索したい場合（今回はID検索と想定）
今回はUsersTableのID:3（ワカメ）を検索（条件の追加）します。
```https://anime.co.jp/sales/1/members?id=3```

# HTTPメソッドとは?
### Hypertext Transfer Protocol (HTTP) で使用されるリクエストの種類を定義する手段。
クライアントがサーバーに送信するリクエストの目的を示し、それに基づいてサーバーは適切な処理を行います。

| HTTPメソッド | はたらき |
| ---- | ---- |
| GET| リソース情報を取得する |
| POST | 新しいリソース情報を送り込む |
| PUT| リソース情報を新しい情報で置き換える |
| PATCH| リソース情報の一部を新しい情報で書き換える |
|DELETE| リソース情報を削除する |

これらのメソッドは、HTTPプロトコルにおいてクライアントとサーバー間でデータの取得、作成、更新、削除などの操作を行うために使用される。

# リクエストヘッダーとは？
HTTPリクエストを構成する部品のひとつであり、
ホームページを見るときに使うソフト（Webブラウザ）からホームページのファイルが置いてあるコンピュータ（Webサーバ）に伝えたいHTTPメソッド（「お願いごとやお願い元に関するあれこれ」）が書かれている場所です。

HTTPリクエストは、
１．[HTTPリクエストライン](https://wa3.i-3-i.info/word1843.html)（リクエストライン）
２．HTTPリクエストヘッダ（ヘッダ）
３．[HTTPリクエストメッセージボディ](https://wa3.i-3-i.info/word1845.html)（メッセージボディ）
の3つです。構造としては「リクエストライン」「ヘッダ」
「[空行]」(```https://wa3.i-3-i.info/word15038.html```)「メッセージボディ」のようになっています。

![image](https://github.com/koikekatsumi/github-handson/assets/163390515/7888820d-1b86-424b-9322-b0152ff403a0)
HTTPリクエストヘッダに入るのは、HTTPメソッド（ブラウザさんからWebサーバさんに伝えたい情報）です。
実際のHTTPリクエストは、例えば以下のような内容になっています。

POST /search.html HTTP/1.1\r\n
Host: wa3.i-3-i.info\r\n
Connection: keep-alive\r\n
Content-Length: 38\r\n
Cache-Control: max-age=0\r\n
Origin: ```http://wa3.i-3-i.info\r\n```
Upgrade-Insecure-Requests: 1\r\n
User-Agent: うんちゃら\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n
Referer: ```http://wa3.i-3-i.info/index.html\r\n```
Accept-Encoding: gzip, deflate\r\n
Accept-Language: ja,en-US;q=0.8,en;q=0.6\r\n
\r\n
q=test&submitSearch=%E6%A4%9C%E7%B4%A2

ごちゃごちゃしていて分かりにくいですが、2行目から空行（\r\nだけの行）までのがHTTPリクエストヘッダです。

Host: wa3.i-3-i.info\r\n
Connection: keep-alive\r\n
Content-Length: 38\r\n
Cache-Control: max-age=0\r\n
Origin: ```http://wa3.i-3-i.info\r\n```
Upgrade-Insecure-Requests: 1\r\n
User-Agent: うんちゃら\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n
Referer: ```http://wa3.i-3-i.info/index.html\r\n```
Accept-Encoding: gzip, deflate\r\n
Accept-Language: ja,en-US;q=0.8,en;q=0.6\r\n

HTTPリクエストヘッダの書式は【フィールド名】:【内容】です。
この書式で必要な数だけ縦にズラズラっと並びます。

【フィールド名】に書かれるのは下記の「[User-Agent](https://wa3.i-3-i.info/word1452.html)」などです。
【内容】には、それらの項目に対する実際の値が入ります。
-  **User-Agent**: リクエストを行ったクライアント（ブラウザやアプリケーション）の情報を提供する。これにより、サーバーはリクエストを送信したクライアントの種類やバージョンを判断できます。
- **Accept**: クライアントが受け入れ可能なコンテンツタイプを指定する。サーバーはこれを参照して、適切な形式のレスポンスを提供することができます。
- **Authorization**: 認証情報を含み、クライアントが保護されたリソースにアクセスする際に使用されます。
- **Content-Type**: リクエスト本文のデータ形式を指定する。例えば、JSON、XML、またはmultipart/form-dataなどがあります。
- **Cookie**: クライアントがサーバーに保存したクッキーを含み、セッションの管理や認証などの目的で使用されます。
これらは一般的なリクエストヘッダーの例だが、HTTPプロトコルには他にも多くのヘッダーが定義され、これらのヘッダーは、リクエストの目的や条件をサーバーに伝えるのに役立つます。

# HTTPステータスコードとは?
HTTPステータスコードはWebサーバーからのレスポンスの結果を表す、3桁の数字コードのことです。
この3桁のステータスコードは、サーバーからの応答の一部としてクライアントに送信されます。クライアント（通常はWebブラウザ）は、それを受け取って、適切な処理を行います。 一般的なHTTPステータスコードは以下の3桁の数字で構成されます。

100番台は、リクエストが受け取られ、処理が継続されていることを意味します。
200番台は、処理が成功して正常にレスポンスができている状態を意味します。
300番台は、リクエストの完了に追加処理が必要である状態を意味します。
400番台は、Webブラウザからのリクエストに誤りがあって、レスポンスを返せなかったことを意味します。
500番台は、サーバーがブラウザからのリクエストの処理に失敗した状態を意味します。

- 200 OK (正しく表示されている)
- 201 Created (作成完了)
- 400 Bad Request (不正なリクエスト)
- 404 Not Found (リソースが見つからない)
- 500 Internal Server Error (サーバー内部のエラー)

# レスポンスヘッダーとは?
**HTTPレスポンス**の意味は、クライアントから送信されたデータをサーバが処理をしてクライアントに返信する応答のことです。
**レスポンスヘッダー**は、レスポンスのメタデータや追加情報を提供し、クライアントがレスポンスを処理する際に役立ちます。
![image](https://github.com/koikekatsumi/github-handson/assets/163390515/97995fc9-86a9-494f-b95e-cd23459c154b)

- Content-Type: レスポンス本文のデータ形式を示す。例えば、テキストやHTML、JSON、画像ファイルなどがあります。
- Content-Length: レスポンス本文のサイズをバイト単位で示します。
- Cache-Control: クライアントがレスポンスをどのようにキャッシュするかを指定します。
- Location: リダイレクトレスポンスにおいて、新しいリソースの場所を示します。
- Server: サーバーの種類やバージョンを示します。
- Set-Cookie: サーバーがクライアントに送信するクッキー情報を含み、セッションの管理やトラッキングに使用されます。
一般的なレスポンスヘッダーの例だが、HTTPプロトコルには他にも多くのヘッダーが定義され、レスポンスヘッダーは、クライアントがサーバーからの応答を理解し、レスポンスを適切に処理するのに役立ちます。

# レスポンスボディとは?
**レスポンスボディ**は、クライアントがサーバーから送信されたデータを受け取るための部分、そのデータはHTTPレスポンスの目的や内容に応じて異なります。リクエストボディと同じようにレスポンスヘッダーとレスポンスボディは空行で区切られます。

HTTPレスポンスは、サーバーがクライアントのリクエストに対して返す内容を表す。レスポンスヘッダーがメタデータや追加情報を提供するのに対して、レスポンスボディは実際のコンテンツを含みます。

レスポンスボディの内容は、サーバーの応答によって異なり、例えば、HTMLページ、JSONデータ、画像ファイル、動画ファイルなどがレスポンスボディとして送信されることがあります。

一般的なWebブラウザを使用してWebページにアクセスする場合、レスポンスボディにはHTMLコンテンツが含まれる。このHTMLコンテンツは、ブラウザが解釈して画面上に表示されます。また、RESTful APIを使用してHTTPリクエストを行う場合、レスポンスボディにはJSON形式やXML形式のデータが含まれることがよくあります。過去に、XML形式は、JSON形式が使用前にされていました。

# JSONとは？
（JavaScript Object Notation）とは、[JavaScript](https://e-words.jp/w/JavaScript.html)における[オブジェクト](https://e-words.jp/w/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88.html)の表記法を応用した[テキスト](https://e-words.jp/w/%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88.html)（文字）ベースの[データ](https://e-words.jp/w/%E3%83%87%E3%83%BC%E3%82%BF.html)形式。多数の要素が複雑な構造で組み合わせられた[データ](https://e-words.jp/w/%E3%83%87%E3%83%BC%E3%82%BF.html)を簡潔な表記で書き表すことができる。[JavaScript](https://e-words.jp/w/JavaScript.html)[プログラム](https://e-words.jp/w/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0.html)上では[コード](https://e-words.jp/w/%E3%82%B3%E3%83%BC%E3%83%89.html)として実行するだけで読み込みが完了する。

## JSON特徴
- データ量が軽い
- 言語に依存しない
- 読みやすい構造

## JSONの記述方法
{}で囲む
キー(key)と値は(value)をコロンで区切って格納
2で作成したデータをそれぞれカンマで区切る
まず、JSON形式にしたいデータを囲むための{}(波括弧)を用意します。JSONに格納するデータはキー(key)と値(value)という形にする必要があり、キーと値をコロンで区切ります。これで1組のデータが完成します。この時、値には様々なデータ型を指定できるのですが、キーには必ず文字列型を指定します。そして、組みになったデータをカンマで区切ります。

## 下記にJSONでデータを扱う場合、ユーザー情報など例を表現

```json
{
"memberId":1,
"memberName": "Tanaka Hanako",
"age": 20
}
```
簡単に上記のコードを解説すると、memberIdというキー名に1という整数の値が入れられています。そして、memberNameというキー名に「Tanaka Hanako」という文字列の値が入られています。最後にageというキー名に20という整数の値が入れられいます。キーも値も文字列を指定する場合はダブルクォーテーションで囲みます。たったこれだけで、様々なプログラミング言語や場面で使用できるという点が人気でJSONは広く使われています。さらにJSONの特徴でも少し紹介しましたが、JSONはXMLに比べてデータ量が軽量です。XMLでもJSONのようなデータ表記はできますが、データ量が重いのです。なので、まとまったデータをやり取りするにはJSONの方がデータ量が軽いので適していると言えるでしょう。
